//Contract based on https://docs.openzeppelin.com/contracts/3.x/erc721
// SPDX-License-Identifier: MIT
pragma solidity ^0.7.3;

import "@openzeppelin/contracts/token/ERC721/ERC721.sol";
import "@openzeppelin/contracts/utils/Counters.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/utils/math/SafeMath.sol";
import "@openzeppelin/contracts/access/AccessControl.sol";


contract MiniMich is ERC721,AccessControl {
    using SafeMath for uint256;
    using Counters for Counters.Counter;
    Counters.Counter private _tokenIds;
    uint256 public _maxSupply = 10000;
    uint256 public totalSupply;
    bool public isSaleActive = true;
    uint256 private price = 10000000000000000; // 0.01 Ether

    // Create a new role identifier for the minter role
    bytes32 public constant MINTER_ROLE = keccak256("MINTER_ROLE");

    constructor(address minter) public ERC20("MyToken", "TKN") {
        // Grant the minter role to a specified account
        _setupRole(MINTER_ROLE, minter);
    }

    address payable private _owner;

    constructor() public ERC721("Mini-Mich", "MM") {
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
    }

    function mintNFT(address recipient, string memory tokenURI)
	public virtual payable
        returns (uint256)
    {
	require(isSaleActive, "Sale is not active");
	require(hasRole(MINTER_ROLE, msg.sender), "Caller is not a minter");
	// No one should own more than two square
        require(balanceOf(recipient) <= 1, 'Each address may only own two square');
        require(totalSupply<=_maxSupply);
	require(msg.value >= price, "Not enough ETH sent; check price!");
          
        _tokenIds.increment();

        uint256 newItemId = _tokenIds.current();
        _mint(recipient, newItemId);
        _setTokenURI(newItemId, tokenURI);

	totalSupply = totalSupply + 1;

        return newItemId;
    }
    
    // smartcontract selling status
    function flipSaleStatus() public onlyOwner {
        isSaleActive = !isSaleActive;
    }
    function maxSupply() public view returns (uint256){
        return _maxSupply;
    }
    function withdraw(address payable recipient) public onlyOwner {
        uint256 balance = address(this).balance;
        recipient.transfer(balance);
    }
}
